//! High level testing focused on the CPU.
//!
//! Most tests will execute a test rom and compare cycle for cycle against a tracelog generated by BSNES.
use std::fs::File;
use std::io;
use std::io::BufRead;
use std::path::Path;
use std::path::PathBuf;

use anyhow::Result;
use log::error;
use pretty_assertions::assert_eq;
use sres_emulator::common::bus::Bus;
use sres_emulator::common::logging;
use sres_emulator::common::util::format_memory;
use sres_emulator::components::cartridge::Cartridge;
use sres_emulator::components::cpu::CpuState;
use sres_emulator::CpuT;
use sres_emulator::System;

#[test]
pub fn test_krom_adc() {
    run_rom_test("krom_adc");
}

#[test]
pub fn test_krom_and() {
    run_rom_test("krom_and");
}

#[test]
pub fn test_krom_asl() {
    run_rom_test("krom_asl");
}

#[test]
pub fn test_krom_bit() {
    run_rom_test("krom_bit");
}

#[test]
pub fn test_krom_bra() {
    run_rom_test("krom_bra");
}

#[test]
pub fn test_krom_cmp() {
    run_rom_test("krom_cmp");
}

#[test]
pub fn test_krom_dec() {
    run_rom_test("krom_dec");
}

#[test]
pub fn test_krom_eor() {
    run_rom_test("krom_eor");
}

#[test]
pub fn test_krom_inc() {
    run_rom_test("krom_inc");
}

#[test]
pub fn test_krom_jmp() {
    run_rom_test("krom_jmp");
}

#[test]
pub fn test_krom_ldr() {
    run_rom_test("krom_ldr");
}

#[test]
pub fn test_krom_lsr() {
    run_rom_test("krom_lsr");
}

#[test]
pub fn test_krom_mov() {
    run_rom_test("krom_mov");
}

#[test]
#[ignore = "Instructions not implemented yet"]
pub fn test_krom_msc() {
    run_rom_test("krom_msc");
}

#[test]
pub fn test_krom_ora() {
    run_rom_test("krom_ora");
}

#[test]
pub fn test_krom_phl() {
    run_rom_test("krom_phl");
}

#[test]
pub fn test_krom_psr() {
    run_rom_test("krom_psr");
}

#[test]
pub fn test_krom_ret() {
    run_rom_test("krom_ret");
}

#[test]
pub fn test_krom_rol() {
    run_rom_test("krom_rol");
}

#[test]
pub fn test_krom_ror() {
    run_rom_test("krom_ror");
}

#[test]
pub fn test_krom_sbc() {
    run_rom_test("krom_sbc");
}

#[test]
pub fn test_krom_str() {
    run_rom_test("krom_str");
}

#[test]
pub fn test_krom_trn() {
    run_rom_test("krom_trn");
}

#[test]
pub fn test_ppu_timing() {
    run_rom_test("ppu_timing");
}

fn run_rom_test(test_name: &str) {
    logging::test_init(true);

    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let trace_path = root_dir.join(format!("tests/rom_tests/{test_name}-trace.log.xz"));
    let rom_path = root_dir.join(format!("tests/rom_tests/{test_name}.sfc"));

    let mut system = System::with_cartridge(&Cartridge::with_sfc_file(&rom_path).unwrap());
    // CPUMSC reads 0x93 from $000000 at the first instruction. I cannot figure out why, it
    // should be mapped to RAM.
    system.cpu.bus.cycle_write_u8(0x000000.into(), 0x93);
    system.cpu.reset();

    for (line_num, expected_line) in trace_log_from_xz_file(&trace_path).unwrap().enumerate() {
        let actual_line = system.cpu.debug().state();
        assert_cpu_trace_eq(line_num, expected_line.unwrap(), actual_line);
        system.execute_one_instruction();
    }
}

fn assert_cpu_trace_eq(i: usize, mut expected: CpuState, mut actual: CpuState) {
    // Disassembly for branch instructions prints the absolute operand address, not the
    // relative address.
    if expected.instruction.operation.starts_with('b') && expected.instruction.operation != "bit" {
        actual.instruction.operand_str = None;
        expected.instruction.operand_str = None;
    }
    // `per` instruction prints relative address as effective address, not the calculated
    // absolute address.
    if expected.instruction.operation == "per" {
        actual.instruction.operand_str = None;
        expected.instruction.operand_str = None;
        actual.instruction.effective_addr = None;
        expected.instruction.effective_addr = None;
    }
    // `jmp` instructions in bsnes print an inconsistent effective address. Skip comparison.
    if expected.instruction.operation.starts_with('j') {
        actual.instruction.effective_addr = None;
        expected.instruction.effective_addr = None;
    }

    if actual != expected {
        error!("Assertion failed at instruction {i}");
        assert_eq!(actual.to_string(), expected.to_string());
    }
}

#[test]
pub fn test_dma_vram() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into VRAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_vram");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0000..=0x00FF)),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0100..=0x01FF)),
        format_memory(&expected),
    );
}

#[test]
pub fn test_dma_cgram() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into CGRAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_cgram");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0000..=0x00FF)),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0100..=0x01FF)),
        format_memory(&expected),
    );
}

#[test]
pub fn test_dma_oam() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into OAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_oam");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0000..=0x00FF)),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0100..=0x01FF)),
        format_memory(&expected),
    );
}

fn run_test_rom(test_name: &str) -> CpuT {
    logging::test_init(false);

    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let rom_path = root_dir.join(format!("tests/rom_tests/{test_name}.sfc"));

    let mut system = System::with_cartridge(&Cartridge::with_sfc_file(&rom_path).unwrap());
    system.cpu.reset();

    while !system.cpu.halted() {
        system.cpu.step();
    }
    system.cpu
}

pub fn trace_log_from_xz_file(path: &Path) -> Result<impl Iterator<Item = Result<CpuState>>> {
    use xz2::read::XzDecoder;
    let file = File::open(path)?;
    let decoder = XzDecoder::new(file);
    let trace_reader = io::BufReader::new(decoder);
    Ok(trace_reader.lines().map(|l| l?.parse()))
}
