//! High level testing focused on the CPU.
//!
//! Most tests will execute a test rom and compare cycle for cycle against a tracelog generated by BSNES.
use std::collections::VecDeque;
use std::fs::File;
use std::io;
use std::io::BufRead;
use std::path::Path;
use std::path::PathBuf;

use anyhow::Result;
use log::error;
use pretty_assertions::assert_eq;
use sres_emulator::common::bus::Bus;
use sres_emulator::common::logging;
use sres_emulator::common::util::format_memory;
use sres_emulator::components::cartridge::Cartridge;
use sres_emulator::components::cpu::CpuEvent;
use sres_emulator::components::cpu::CpuState;
use sres_emulator::components::spc700::Spc700Event;
use sres_emulator::components::spc700::Spc700State;
use sres_emulator::debugger::DebugEvent;
use sres_emulator::debugger::EventFilter;
use sres_emulator::CpuT;
use sres_emulator::System;

#[test]
pub fn test_krom_adc() {
    run_rom_test("krom_adc");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_and() {
    run_rom_test("krom_and");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_asl() {
    run_rom_test("krom_asl");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_bit() {
    run_rom_test("krom_bit");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_bra() {
    run_rom_test("krom_bra");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_cmp() {
    run_rom_test("krom_cmp");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_dec() {
    run_rom_test("krom_dec");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_eor() {
    run_rom_test("krom_eor");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_inc() {
    run_rom_test("krom_inc");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_jmp() {
    run_rom_test("krom_jmp");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_ldr() {
    run_rom_test("krom_ldr");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_lsr() {
    run_rom_test("krom_lsr");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_mov() {
    run_rom_test("krom_mov");
}

#[test]
#[ignore = "Instructions not implemented yet"]
pub fn test_krom_msc() {
    run_rom_test("krom_msc");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_ora() {
    run_rom_test("krom_ora");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_phl() {
    run_rom_test("krom_phl");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_psr() {
    run_rom_test("krom_psr");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_ret() {
    run_rom_test("krom_ret");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_rol() {
    run_rom_test("krom_rol");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_ror() {
    run_rom_test("krom_ror");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_sbc() {
    run_rom_test("krom_sbc");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_str() {
    run_rom_test("krom_str");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_krom_trn() {
    run_rom_test("krom_trn");
}

#[test]
pub fn test_ppu_timing() {
    run_rom_test("ppu_timing");
}

#[test]
#[ignore = "trace format not migrated to mesen format"]
pub fn test_play_noise() {
    run_rom_test_with_spc700_trace("play_noise");
}

fn run_rom_test(test_name: &str) {
    logging::test_init(true);

    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let trace_path = root_dir.join(format!("tests/rom_tests/{test_name}-trace.log.xz"));
    let rom_path = root_dir.join(format!("tests/rom_tests/{test_name}.sfc"));

    let mut system = System::with_cartridge(&Cartridge::with_sfc_file(&rom_path).unwrap());
    // CPUMSC reads 0x93 from $000000 at the first instruction. I cannot figure out why, it
    // should be mapped to RAM.
    system.cpu.bus.cycle_write_u8(0x000000.into(), 0x93);
    system.cpu.reset();

    system.debugger().enable();
    system.debugger().add_log_point(EventFilter::CpuStep);

    let mut prev_clock: Option<u64> = None;
    let mut actual_state_log = VecDeque::new();

    for (line_num, expected_line) in trace_log_from_xz_file(&trace_path).unwrap().enumerate() {
        if actual_state_log.is_empty() {
            system.execute_one_instruction();
            actual_state_log.extend(system.debugger().log.drain().filter_map(|e| match e {
                DebugEvent::Cpu(CpuEvent::Step(state)) => Some(state),
                _ => None,
            }));
        }
        let actual_line = actual_state_log.pop_front().unwrap();
        let expected_line = expected_line.unwrap();

        // Check timing separately
        if let Some(prev) = prev_clock {
            let actual_delta = actual_line.clock.master_clock - prev;
            let expected_delta = expected_line.clock.master_clock - prev;
            if actual_delta != expected_delta {
                error!(
                    "Instruction duration mismatch: actual={actual_delta} cycles, expected={expected_delta} cycles. SRES is off by {} cycles",
                    (expected_delta as i64) - (actual_delta as i64)
                );
            }
        }

        prev_clock = Some(actual_line.clock.master_clock);

        assert_cpu_trace_eq(line_num, expected_line, actual_line);
    }
}

fn run_rom_test_with_spc700_trace(test_name: &str) {
    logging::test_init(true);

    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let trace_path = root_dir.join(format!("tests/rom_tests/{test_name}-trace.log.xz"));
    let rom_path = root_dir.join(format!("tests/rom_tests/{test_name}.sfc"));

    let mut system = System::with_cartridge(&Cartridge::with_sfc_file(&rom_path).unwrap());
    // CPUMSC reads 0x93 from $000000 at the first instruction. I cannot figure out why, it
    // should be mapped to RAM.
    system.cpu.bus.cycle_write_u8(0x000000.into(), 0x93);
    system.cpu.reset();

    system.debugger().enable();
    system.debugger().add_log_point(EventFilter::Spc700Step);

    let mut actual_state_log = VecDeque::new();
    for (line_num, expected_line) in mixed_trace_log_from_xz_file(&trace_path)
        .unwrap()
        .enumerate()
    {
        // Only up to line 65 works so far. Things get out of sync after that.
        // TODO: Fix remaining lines.
        if line_num >= 65 {
            break;
        }
        // Each emulator step may generate multiple spc instructions.
        if actual_state_log.is_empty() {
            actual_state_log.extend(system.debugger().log.drain().filter_map(|e| match e {
                DebugEvent::Spc700(Spc700Event::Step(state)) => Some(MixedTrace::Spc700(state)),
                _ => None,
            }));
            actual_state_log.push_front(MixedTrace::Cpu(system.cpu.debug().state()));
            system.execute_one_instruction();
        }
        let expected_line = expected_line.unwrap();
        let actual_state = actual_state_log.pop_back().unwrap();
        println!("{}", actual_state);
        match (actual_state, expected_line) {
            (MixedTrace::Cpu(actual_cpu), MixedTrace::Cpu(expected_cpu)) => {
                assert_cpu_trace_eq(line_num, expected_cpu, actual_cpu);
            }
            (MixedTrace::Spc700(actual_spc), MixedTrace::Spc700(expected_spc)) => {
                assert_spc_trace_eq(line_num, expected_spc, actual_spc);
            }
            (actual, expected) => {
                error!("Assertion failed at instruction {line_num}");
                assert_eq!(actual.to_string(), expected.to_string());
            }
        }
    }
}

fn assert_cpu_trace_eq(_i: usize, mut expected: CpuState, mut actual: CpuState) {
    // TODO: This emulator does not implement open bus reads, which means that memory values shown
    // in the trace on write-only MMIO registers will not be correct.
    actual.instruction.effective_addr_and_value = None;
    expected.instruction.effective_addr_and_value = None;

    assert_eq!(actual.to_string(), expected.to_string());
}

fn assert_spc_trace_eq(i: usize, expected: Spc700State, actual: Spc700State) {
    if actual != expected {
        error!("Assertion failed at instruction {i}");
        assert_eq!(actual.to_string(), expected.to_string());
    }
}

#[test]
pub fn test_dma_vram() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into VRAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_vram");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0000..=0x00FF)),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0100..=0x01FF)),
        format_memory(&expected),
    );
}

#[test]
pub fn test_dma_cgram() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into CGRAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_cgram");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0000..=0x00FF)),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0100..=0x01FF)),
        format_memory(&expected),
    );
}

#[test]
pub fn test_dma_oam() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into OAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_oam");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0000..=0x00FF)),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.peek_range(0x0100..=0x01FF)),
        format_memory(&expected),
    );
}

fn run_test_rom(test_name: &str) -> CpuT {
    logging::test_init(false);

    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let rom_path = root_dir.join(format!("tests/rom_tests/{test_name}.sfc"));

    let mut system = System::with_cartridge(&Cartridge::with_sfc_file(&rom_path).unwrap());
    system.cpu.reset();

    while !system.cpu.halted() {
        system.cpu.step();
    }
    system.cpu
}

pub fn trace_log_from_xz_file(path: &Path) -> Result<impl Iterator<Item = Result<CpuState>>> {
    use xz2::read::XzDecoder;
    let file = File::open(path)?;
    let decoder = XzDecoder::new(file);
    let trace_reader = io::BufReader::new(decoder);
    Ok(trace_reader
        .lines()
        .map(|l| CpuState::parse_mesen_trace(&l?)))
}

#[derive(Debug, PartialEq)]
enum MixedTrace {
    Cpu(CpuState),
    Spc700(Spc700State),
}

impl std::fmt::Display for MixedTrace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MixedTrace::Cpu(state) => write!(f, "{}", state),
            MixedTrace::Spc700(state) => write!(f, "{}", state),
        }
    }
}

fn mixed_trace_log_from_xz_file(path: &Path) -> Result<impl Iterator<Item = Result<MixedTrace>>> {
    use xz2::read::XzDecoder;
    let file = File::open(path)?;
    let decoder = XzDecoder::new(file);
    let trace_reader = io::BufReader::new(decoder);
    Ok(trace_reader.lines().map(|l| {
        let l = l?;
        Ok(if l.starts_with("..") {
            MixedTrace::Spc700(l.parse::<Spc700State>()?)
        } else {
            MixedTrace::Cpu(CpuState::parse_mesen_trace(&l)?)
        })
    }))
}
