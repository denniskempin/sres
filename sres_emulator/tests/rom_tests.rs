//! High level testing focused on the CPU.
//!
//! Most tests will execute a test rom and compare cycle for cycle against a tracelog generated by BSNES.
use std::fs::File;
use std::io;
use std::io::BufRead;
use std::path::Path;
use std::path::PathBuf;

use anyhow::Result;
use log::error;
use pretty_assertions::assert_eq;
use sres_emulator::bus::Bus;
use sres_emulator::bus::Wrap;
use sres_emulator::cartridge::Cartridge;
use sres_emulator::cpu::Cpu;
use sres_emulator::main_bus::MainBusImpl;
use sres_emulator::trace::CpuTraceLine;
use sres_emulator::trace::Spc700TraceLine;
use sres_emulator::trace::TraceLine;
use sres_emulator::util::logging;
use sres_emulator::util::memory::format_memory;
use sres_emulator::System;

#[test]
pub fn test_nmi_sub_cycle_accuracy() {
    static TEST_CASES: &[(u64, u64, bool, bool)] = &[
        // The `bit $4210` instruction is often used to check the NMI signal, to wait for VSYNC.
        // This makes the instruction very sensitive to sub-cpu-cycle timing, as the result will
        // depend on when exactly the signal is read.
        //
        // The list below is the result of `bit $4210` executed at various points in the frame. This
        // matches the behavior of BSNES.
        //
        // Starting 1334, the bit instruction will end after NMI and the internal NMI flag will
        // be set after the instruction is executed.
        //
        // Starting 1340, NMI will be high by the time the bit instruction reads the state. Usually
        // reads from $4210 will reset the NMI flag, but not for the first 4 cycles.
        //
        // (V, H, nmi returned by `bit`, internal nmi flag)
        (224, 1330, false, false),
        (224, 1332, false, false),
        (224, 1334, false, true),
        (224, 1336, false, true),
        (224, 1338, false, true),
        (224, 1340, true, true),
        (224, 1342, true, true),
        (224, 1344, true, false),
        (224, 1346, true, false),
        (224, 1348, true, false),
        (224, 1350, true, false),
        (224, 1352, true, false),
        (224, 1354, true, false),
        (224, 1356, true, false),
        (224, 1358, true, false),
        (224, 1360, true, false),
        (224, 1362, true, false),
        (225, 0, true, false),
    ];
    for (v, h, expected_nmi, expected_internal_nmi) in TEST_CASES {
        // Create CPU with `bit $4210` program in memory
        let mut system = System::new();
        let cpu = &mut system.cpu;
        let bus = &mut cpu.bus;
        bus.cycle_write_u16(0x00.into(), 0x2C, Wrap::NoWrap);
        bus.cycle_write_u16(0x01.into(), 0x4210, Wrap::NoWrap);
        cpu.reset();

        // Advance PPU timer until (v, h) is reached
        while cpu.bus.ppu.timer.v != *v || cpu.bus.ppu.timer.h_counter != *h {
            cpu.bus.ppu.timer.advance_master_clock(2);
        }

        // Execute `bit $4210` instruction
        println!("before: {}", CpuTraceLine::from_cpu(cpu));
        cpu.step();
        println!("after: {}", CpuTraceLine::from_cpu(cpu));

        // If the NMI bit is set, the negative status bit will be true.
        assert_eq!(cpu.status.negative, *expected_nmi);
        // For the first 4 cycles NMI will remain high, so the internal nmi_flag will still be set.
        assert_eq!(cpu.bus.nmi_flag, *expected_internal_nmi);
    }
}

#[test]
pub fn test_krom_adc() {
    run_rom_test("krom_adc", false);
}

#[test]
pub fn test_krom_and() {
    run_rom_test("krom_and", false);
}

#[test]
pub fn test_krom_asl() {
    run_rom_test("krom_asl", false);
}

#[test]
pub fn test_krom_bit() {
    run_rom_test("krom_bit", false);
}

#[test]
pub fn test_krom_bra() {
    run_rom_test("krom_bra", false);
}

#[test]
pub fn test_krom_cmp() {
    run_rom_test("krom_cmp", false);
}

#[test]
pub fn test_krom_dec() {
    run_rom_test("krom_dec", false);
}

#[test]
pub fn test_krom_eor() {
    run_rom_test("krom_eor", false);
}

#[test]
pub fn test_krom_inc() {
    run_rom_test("krom_inc", false);
}

#[test]
pub fn test_krom_jmp() {
    run_rom_test("krom_jmp", false);
}

#[test]
pub fn test_krom_ldr() {
    run_rom_test("krom_ldr", false);
}

#[test]
pub fn test_krom_lsr() {
    run_rom_test("krom_lsr", false);
}

#[test]
pub fn test_krom_mov() {
    run_rom_test("krom_mov", false);
}

#[test]
#[ignore = "Instructions not implemented yet"]
pub fn test_krom_msc() {
    run_rom_test("krom_msc", false);
}

#[test]
pub fn test_krom_ora() {
    run_rom_test("krom_ora", false);
}

#[test]
pub fn test_krom_phl() {
    run_rom_test("krom_phl", false);
}

#[test]
pub fn test_krom_psr() {
    run_rom_test("krom_psr", false);
}

#[test]
pub fn test_krom_ret() {
    run_rom_test("krom_ret", false);
}

#[test]
pub fn test_krom_rol() {
    run_rom_test("krom_rol", false);
}

#[test]
pub fn test_krom_ror() {
    run_rom_test("krom_ror", false);
}

#[test]
pub fn test_krom_sbc() {
    run_rom_test("krom_sbc", false);
}

#[test]
pub fn test_krom_str() {
    run_rom_test("krom_str", false);
}

#[test]
pub fn test_krom_trn() {
    run_rom_test("krom_trn", false);
}

#[test]
pub fn test_ppu_timing() {
    run_rom_test("ppu_timing", false);
}

#[test]
#[ignore = "not implemented yet"]
pub fn test_play_noise() {
    run_rom_test("play_noise", true);
}

fn run_rom_test(test_name: &str, check_spc700: bool) {
    logging::test_init(false);

    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let trace_path = root_dir.join(format!("tests/rom_tests/{test_name}-trace.log.xz"));
    let rom_path = root_dir.join(format!("tests/rom_tests/{test_name}.sfc"));

    let mut system = System::with_cartridge(&Cartridge::with_sfc_file(&rom_path).unwrap());
    system.enable_debugger();
    // CPUMSC reads 0x93 from $000000 at the first instruction. I cannot figure out why, it
    // should be mapped to RAM.
    system.cpu.bus.cycle_write_u8(0x000000.into(), 0x93);
    system.cpu.reset();

    let mut expected_trace_lines = trace_log_from_xz_file(&trace_path).unwrap();
    let mut line_num = 0;
    loop {
        // Execute one instruction, then compare trace log against expected_trace_lines.
        system.execute_one_instruction();
        let trace = system.debugger().consume_trace();
        assert!(!trace.is_empty());
        for actual_line in trace {
            println!("{}", actual_line);
            if !check_spc700 && matches!(actual_line, TraceLine::Spc700(_)) {
                continue;
            }

            let expected_line = expected_trace_lines.next();
            if expected_line.is_none() {
                return;
            }
            let expected_line = expected_line.unwrap().unwrap();

            match (expected_line, actual_line) {
                (TraceLine::Cpu(expected), TraceLine::Cpu(actual)) => {
                    compare_cpu_trace(line_num, expected, actual);
                }
                (TraceLine::Spc700(expected), TraceLine::Spc700(actual)) => {
                    compare_spc700_trace(line_num, expected, actual);
                }
                (expected_line, actual_line) => {
                    error!("Unexpected trace line type at instruction {line_num}");
                    assert_eq!(actual_line.to_string(), expected_line.to_string());
                }
            }
        }
        line_num += 1;
    }
}

fn compare_spc700_trace(_i: usize, expected: Spc700TraceLine, actual: Spc700TraceLine) {
    assert_eq!(actual.to_string(), expected.to_string())
}

fn compare_cpu_trace(i: usize, mut expected: CpuTraceLine, mut actual: CpuTraceLine) {
    // Disassembly for branch instructions prints the absolute operand address, not the
    // relative address.
    if expected.instruction.operation.starts_with('b') && expected.instruction.operation != "bit" {
        actual.instruction.operand_str = None;
        expected.instruction.operand_str = None;
    }
    // `per` instruction prints relative address as effective address, not the calculated
    // absolute address.
    if expected.instruction.operation == "per" {
        actual.instruction.operand_str = None;
        expected.instruction.operand_str = None;
        actual.instruction.effective_addr = None;
        expected.instruction.effective_addr = None;
    }
    // `jmp` instructions in bsnes print an inconsistent effective address. Skip comparison.
    if expected.instruction.operation.starts_with('j') {
        actual.instruction.effective_addr = None;
        expected.instruction.effective_addr = None;
    }

    if actual != expected {
        error!("Assertion failed at instruction {i}");
        assert_eq!(actual.to_string(), expected.to_string());
    }
}

#[test]
pub fn test_dma_vram() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into VRAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_vram");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.wram[0x0000..=0x00FF]),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.wram[0x0100..=0x01FF]),
        format_memory(&expected),
    );
}

#[test]
pub fn test_dma_cgram() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into CGRAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_cgram");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.wram[0x0000..=0x00FF]),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.wram[0x0100..=0x01FF]),
        format_memory(&expected),
    );
}

#[test]
pub fn test_dma_oam() {
    // This rom will generate a test sequence 0x00..0xFF in WRAM at 0x0000, then copies it into OAM via
    // a DMA transfer and copies it back into WRAM at 0x0100.
    let cpu = run_test_rom("dma_oam");
    let expected: Vec<u8> = (0x00..=0xFF).collect();

    // Validate the test sequence at 0x0000
    assert_eq!(
        format_memory(&cpu.bus.wram[0x0000..=0x00FF]),
        format_memory(&expected),
    );

    // Validate the test sequence after it's copied back into WRAM at 0x0100
    assert_eq!(
        format_memory(&cpu.bus.wram[0x0100..=0x01FF]),
        format_memory(&expected),
    );
}

fn run_test_rom(test_name: &str) -> Cpu<MainBusImpl> {
    logging::test_init(false);

    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let rom_path = root_dir.join(format!("tests/rom_tests/{test_name}.sfc"));

    let mut system = System::with_cartridge(&Cartridge::with_sfc_file(&rom_path).unwrap());
    system.cpu.reset();

    while !system.cpu.halt {
        system.cpu.step();
    }
    system.cpu
}

pub fn trace_log_from_xz_file(path: &Path) -> Result<impl Iterator<Item = Result<TraceLine>>> {
    use xz2::read::XzDecoder;
    let file = File::open(path)?;
    let decoder = XzDecoder::new(file);
    let trace_reader = io::BufReader::new(decoder);
    Ok(trace_reader.lines().map(|l| l?.parse()))
}
